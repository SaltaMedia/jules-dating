require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const session = require('express-session');
const passport = require('passport');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const routes = require('./routes/index');
const { logInfo, logError, logWarn, logDebug, logRequest } = require('./utils/logger');
const { errorHandler, notFoundHandler, addRequestId } = require('./utils/errorHandler');
const { initializeCache, closeCache } = require('./utils/cache');
const { 
  createIndexes, 
  optimizeConnection, 
  startPerformanceMonitoring, 
  optimizeSchemas 
} = require('./utils/databaseOptimizer');

// Import Passport configuration
require('./config/passport');

const app = express();
const PORT = process.env.PORT || 4001;

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.openai.com", "https://www.googleapis.com"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

// Rate limiting with environment-based configuration
const isDevelopment = process.env.NODE_ENV !== 'production';

// Chat rate limiter - more generous for chat interactions
const chatLimiter = rateLimit({
  windowMs: parseInt(process.env.CHAT_RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.CHAT_RATE_LIMIT_MAX) || (isDevelopment ? 1000 : 300), // Higher limit for development
  message: {
    error: 'Too many chat requests from this IP, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Auth rate limiter - stricter for security
const authLimiter = rateLimit({
  windowMs: parseInt(process.env.AUTH_RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.AUTH_RATE_LIMIT_MAX) || (isDevelopment ? 500 : 50), // Stricter in production
  message: {
    error: 'Too many authentication attempts, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// General rate limiter - for all other API endpoints
const generalLimiter = rateLimit({
  windowMs: parseInt(process.env.GENERAL_RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.GENERAL_RATE_LIMIT_MAX) || (isDevelopment ? 1000 : 200), // Higher limit for development
  message: {
    error: 'Too many requests from this IP, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply different rate limits to different routes
app.use('/api/auth', authLimiter); // Very strict for auth
app.use('/api/chat', chatLimiter); // More generous for chat
app.use('/api', generalLimiter); // General limit for other endpoints

// Middleware
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : ['http://localhost:3001', 'http://localhost:3002'],
  credentials: true
}));

app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Get session secret with proper error handling
function getSessionSecret() {
  const secret = process.env.SESSION_SECRET;
  if (!secret) {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('SESSION_SECRET environment variable is required in production');
    }
    logWarn('SESSION_SECRET not set, using development fallback. This should not be used in production.');
    return 'dev-session-secret-only-for-development';
  }
  return secret;
}

// Session configuration
app.use(session({
  secret: getSessionSecret(),
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}));

// Passport middleware
app.use(passport.initialize());
app.use(passport.session());

// Analytics middleware - temporarily disabled
// const { 
//   sessionMiddleware, 
//   pageViewMiddleware, 
//   userIdentificationMiddleware,
//   performanceMiddleware 
// } = require('./middleware/analytics');

// app.use(userIdentificationMiddleware);
// app.use(sessionMiddleware);
// app.use(pageViewMiddleware);
// app.use(performanceMiddleware);

// MongoDB connection configuration
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/jules-style';

// MongoDB connection options for production
const mongooseOptions = {
  maxPoolSize: 5, // Reduced pool size
  serverSelectionTimeoutMS: 3000, // Reduced timeout for faster failure
  socketTimeoutMS: 5000, // Reduced timeout
  bufferCommands: false, // Disable mongoose buffering
  retryWrites: false, // Disable retry writes for faster failure
  w: 1, // Reduced write concern
  // Retry settings
  retryReads: false, // Disable retry reads for faster failure
  // SSL settings for production
  ssl: process.env.NODE_ENV === 'production',
  // Authentication settings
  authSource: 'admin',
  // Timeout settings
  connectTimeoutMS: 5000, // Reduced timeout
  // Heartbeat settings
  heartbeatFrequencyMS: 5000, // Reduced heartbeat
};

// Function to connect to MongoDB with retry logic
async function connectToMongoDB() {
  const maxRetries = 1; // Reduced to 1 for faster startup
  let retryCount = 0;

  while (retryCount < maxRetries) {
    try {
      logInfo(`Attempting to connect to MongoDB (attempt ${retryCount + 1}/${maxRetries})`);
      
      // Add a timeout to the connection attempt
      const connectionPromise = mongoose.connect(MONGODB_URI, mongooseOptions);
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Connection timeout')), 10000)
      );
      
      await Promise.race([connectionPromise, timeoutPromise]);
      
      logInfo('Successfully connected to MongoDB', {
        poolSize: mongooseOptions.maxPoolSize,
        database: MONGODB_URI.split('/').pop().split('?')[0]
      });
      
      // Set up connection event listeners
      mongoose.connection.on('error', (err) => {
        logError('MongoDB connection error', err);
      });

      mongoose.connection.on('disconnected', () => {
        logWarn('MongoDB disconnected');
      });

      mongoose.connection.on('reconnected', () => {
        logInfo('MongoDB reconnected');
      });

      return true;
    } catch (error) {
      retryCount++;
      logError(`MongoDB connection attempt ${retryCount} failed`, error);
      
      if (retryCount < maxRetries) {
        const delay = 1000; // Fixed delay instead of exponential backoff
        logInfo(`Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        logError('Failed to connect to MongoDB after all retry attempts');
        logWarn('Server will start without database connection - some features may be limited');
        return false;
      }
    }
  }
}

// Graceful shutdown function
async function gracefulShutdown(signal) {
  logInfo(`Received ${signal}. Starting graceful shutdown...`);
  
  try {
    // Close cache connection
    await closeCache();
    
    // Close MongoDB connection
    if (mongoose.connection.readyState === 1) {
      logInfo('Closing MongoDB connection...');
      await mongoose.connection.close();
      logInfo('MongoDB connection closed');
    }
    
    // Close server
    if (server) {
      logInfo('Closing HTTP server...');
      server.close(() => {
        logInfo('HTTP server closed');
        process.exit(0);
      });
      
      // Force exit after 10 seconds
      setTimeout(() => {
        logError('Forced shutdown after timeout');
        process.exit(1);
      }, 10000);
    } else {
      process.exit(0);
    }
  } catch (error) {
    logError('Error during graceful shutdown', error);
    process.exit(1);
  }
}

// Initialize cache
initializeCache();

// Add request ID and logging middleware
app.use(addRequestId);
app.use(logRequest);

// Routes
app.use('/api', routes);

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'Jules Style Backend API',
    version: '1.0.0',
    status: 'running',
    timestamp: new Date().toISOString()
  });
});

// 404 handler
app.use('*', notFoundHandler);

// Error handling middleware
app.use(errorHandler);

// Start server and capture instance for graceful shutdown
const server = app.listen(PORT, () => {
  logInfo(`Jules Style Backend running on port ${PORT}`, {
    port: PORT,
    environment: process.env.NODE_ENV || 'development',
    healthCheck: `http://localhost:${PORT}/api/health`
  });
});

// Connect to MongoDB and initialize optimizations (non-blocking)
connectToMongoDB().then(async (connected) => {
  if (connected) {
    try {
      // Optimize database connection
      optimizeConnection();
      
      // Create database indexes (with timeout)
      const indexesPromise = createIndexes();
      const indexesTimeout = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Index creation timeout')), 15000)
      );
      await Promise.race([indexesPromise, indexesTimeout]);
      
      // Optimize schemas
      optimizeSchemas();
      
      // Start performance monitoring
      startPerformanceMonitoring();
      
      logInfo('Database initialization completed successfully');
    } catch (error) {
      logError('Database initialization failed, but server will continue:', error);
    }
  } else {
    logWarn('Server running without database connection - some features may be limited');
  }
}).catch((error) => {
  logError('Failed to connect to MongoDB during startup', error);
  logWarn('Server will continue without database connection');
});

// Set up graceful shutdown handlers
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGUSR2', () => gracefulShutdown('SIGUSR2')); // For nodemon

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  logError('Uncaught Exception', err);
  gracefulShutdown('uncaughtException');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logError('Unhandled Rejection', new Error(`Promise: ${promise}, Reason: ${reason}`));
  gracefulShutdown('unhandledRejection');
});